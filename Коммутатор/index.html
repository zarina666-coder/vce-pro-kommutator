<!DOCTYPE html>
<html>
<head>
	<title>
	Коммутатор	
	</title>
</head>
<body>
	<h1 style="position: relative; text-align:center;">Коммутатор</h1>
	<hr>
	<h2 style="position: relative; text-align:center;">Сайт создан для сетевых и системных администраторов!</h2>
	<br>
	<h3 style="position: relative; text-align:center;">Что же такое коммутатор ?</h3>
	<p>Сетевой коммутатор (жарг. свитч, свич от англ. switch «переключатель») — устройство, предназначенное для соединения нескольких узлов компьютерной сети в пределах одного или нескольких сегментов сети. Коммутатор работает на канальном (втором) уровне сетевой модели OSI. Коммутаторы были разработаны с использованием мостовых технологий и часто рассматриваются как многопортовые мосты. Для соединения нескольких сетей на основе сетевого уровня служат маршрутизаторы (3 уровень OSI). 
	В отличие от концентратора (1 уровень OSI), который распространяет трафик от одного подключённого устройства ко всем остальным, коммутатор передаёт данные только непосредственно получателю (исключение составляет широковещательный трафик всем узлам сети и трафик для устройств, для которых неизвестен исходящий порт коммутатора). Это повышает производительность и безопасность сети, избавляя остальные сегменты сети от необходимости (и возможности) обрабатывать данные, которые им не предназначались.</p>
	<img src="img/img1.png">
	<h4 style="position: relative; text-align:center;">Как работает коммутатор ?</h4>
	<p>Коммутатор хранит в памяти (т. н. ассоциативной памяти) таблицу коммутации, в которой указывается соответствие узла порту. При включении коммутатора эта таблица пуста, и он работает в режиме обучения. В этом режиме поступающие на какой-либо порт данные передаются на все остальные порты коммутатора. При этом коммутатор анализирует фреймы (кадры) и, определив MAC-адрес хоста-отправителя, заносит его в таблицу на некоторое время. Впоследствии, если на один из портов коммутатора поступит кадр, предназначенный для хоста, MAC-адрес которого уже есть в таблице, то этот кадр будет передан только через порт, указанный в таблице. Если же MAC-адрес хоста-получателя не ассоциирован с каким-либо портом коммутатора, то кадр будет отправлен на все порты, за исключением того порта, с которого он был получен. Со временем коммутатор строит таблицу для всех активных MAC-адресов, в результате трафик локализуется. Стоит отметить малую задержку и высокую скорость пересылки на каждом порту интерфейса.</p>
	<h5 style="position: relative; text-align:center;">Для чего нужен коммутатор ?</h5>
	<p>Коммутатор нужен для объединения нескольких устройств в локальную сеть для быстрой и удобной передачи данных. 
		Он служит приёмно-сортировочным пунктом, переправляющим пакеты данных от источника к адресату. 
		Некоторые задачи, которые решает коммутатор: <br>
		1. обеспечение быстрого и стабильного сетевого подключения; <br>
		2. обеспечение одновременного доступа большого количества пользователей с сохранением высокой стабильности работы; <br>
		3. создание системы видеонаблюдения с большим количеством камер, передающих изображение на один основной компьютер; <br>
	    4. подсоединение серии датчиков, позволяющих контролировать разные этапы производственного процесса путём передачи показаний на диспетчерский пульт; <br>
        5. использование провайдерами в качестве центрального узла при подключении отдельных абонентов к единому интернет-каналу, подведённому к многоквартирному дому.
    </p>
    <h6 style="position: relative; text-align:center;">Разновидности коммутаторов</h6>
    <p>Коммутаторы подразделяются на управляемые и неуправляемые (наиболее простые).
    	Более сложные коммутаторы позволяют управлять коммутацией на сетевом (третьем) уровне модели OSI. Обычно их именуют соответственно, например «Layer 3 Switch» или сокращенно «L3 Switch». Управление коммутатором может осуществляться посредством Web-интерфейса, интерфейса командной строки (CLI), протокола SNMP, RMON и т. п.
    	Многие управляемые коммутаторы позволяют настраивать дополнительные функции: VLAN, QoS, агрегирование, зеркалирование. Многие коммутаторы уровня доступа обладают такими расширенными возможностями, как сегментация трафика между портами, контроль трафика на предмет штормов, обнаружение петель, ограничение количества изучаемых MAC-адресов, ограничение входящей/исходящей скорости на портах, функции списков доступа и т. п.
        Сложные коммутаторы можно объединять в одно логическое устройство — стек — с целью увеличения числа портов. Например, можно объединить 4 коммутатора с 24 портами и получить логический коммутатор с 90 ((4*24)-6=90) портами либо с 96 портами (если для стекирования используются специальные порты).</p>
    <h7 style="position: relative; text-align:center;">Режимы коммутации</h7>
    <p>Существует три способа коммутации, у которых различаются задержка и надёжность передачи:
    	С промежуточным хранением (store and forward). Коммутатор читает весь кадр, проверяет его на отсутствие ошибок, выбирает порт коммутации и посылает в него весь кадр.
    	Сквозной (cut-through). Коммутатор считывает из кадра только адрес назначения и после посылает весь кадр в соответствующий порт, не проверяя на ошибки. Так как нет необходимости хранить в памяти весь кадр для проверки, коммутатор может послать начало кадра, не получив его конца, так что задержка ниже.
        Бесфрагментный (fragment-free) или гибридный . Этот режим является модификацией сквозного режима, который частично решает проблему коллизий. Повреждённые коллизией кадры часто короче минимально допустимого размера, равного 64 байтам, поэтому в этом режиме коммутатор отбрасывает кадры длиной меньше 64 байт, а все остальные после прочтения первых 64 байт передаёт дальше в сквозном режиме[источник не указан 1408 дней].
        Задержка, связанная с «принятием коммутатором решения», добавляется к времени, которое требуется кадру для входа на порт коммутатора и выхода с него, и вместе с ним определяет общую задержку коммутатора.</p>
    <h8 style="position: relative; text-align:center;">Буфер памяти</h8>  
    <p>В результате коммутации могут одновременно возникнуть два кадра, предназначенные одному порту. Однако, их невозможно отправить через него одновременно, поэтому все поступающие кадры хранятся до отправки в специальной области памяти коммутатора —так называемом буфере.
    	Есть два способа организации буфера: буферизация по портам и буферизация с общей памятью. При буферизации по портам кадры хранятся в очередях (queue), которые связаны с отдельными входными портами. Пакет передаётся на выходной порт только тогда, когда все кадры, находившиеся впереди него в очереди, были успешно переданы. При этом возможна ситуация, когда один кадр задерживает всю очередь из-за занятости порта его пункта назначения. Эта задержка может происходить даже в том случае, когда остальные кадры могут быть переданы на открытые порты своих пунктов назначения.
    	При буферизации в общей памяти все кадры хранятся в общем буфере, который используется всеми портами коммутатора, каждому из которых память выделяется по требованию. Такой метод называется динамическим распределением буферной памяти. После этого кадры, находившиеся в буфере, распределяются по выходным портам. Это позволяет получить кадр на одном порте и отправить его с другого порта, не устанавливая его в очередь.
    	Коммутатор поддерживает карту портов, в которые требуется отправить кадры. Очистка этой карты происходит только после того, как кадр успешно отправлен.
        Поскольку память буфера является общей, размер кадра ограничивается всем размером буфера, а не долей, предназначенной для конкретного порта. Это означает, что крупные кадры могут быть переданы с меньшими потерями, что особенно важно при асимметричной коммутации, то есть, когда порт с шириной полосы пропускания 100 Мбит/с должен отправлять пакеты на порт 10 Мбит/с.</p> 
    <h9 style="position: relative; text-align:center;">Симметричная и асимметричная коммутация</h9> 
    <p>Свойство симметрии при коммутации позволяет дать характеристику коммутатора с точки зрения ширины полосы пропускания для каждого его порта. Симметричный коммутатор обеспечивает коммутируемые соединения между портами с одинаковой шириной полосы пропускания, например, когда все порты имеют ширину пропускания 10 Мбит/с или 100 Мбит/с.
    	Асимметричный коммутатор обеспечивает коммутируемые соединения между портами с различной шириной полосы пропускания, например, в случаях комбинации портов с шириной полосы пропускания 10 Мбит/с или 100 Мбит/с и 1000 Мбит/с.
    	Асимметричная коммутация используется в случае наличия больших сетевых потоков типа клиент-сервер, когда многочисленные пользователи обмениваются информацией с сервером одновременно, что требует большей ширины пропускания для того порта коммутатора, к которому подсоединён сервер, с целью предотвращения переполнения на этом порте. Для того, чтобы направить поток данных с порта 100 Мбит/с на порт 10 Мбит/с без опасности переполнения на последнем, асимметричный коммутатор должен иметь буфер памяти[источник не указан 2595 дней].
    Асимметричный коммутатор также необходим для обеспечения большей ширины полосы пропускания каналов между коммутаторами, осуществляемых через вертикальные кросс-соединения, или каналов между сегментами магистрали.</p>
    <br>
    <hr>
    <h10> Пишем хост неймы: <br>
    	HQ-SRV: hostnamectl hostname hq-srv.au-team.irpo <br>
        HQ-RTR: hostnamectl hostname hq-rtr.au-team.irpo <br>
        ISP: hostnamectl hostname isp.au-team.irpo <br>
        BR-RTR: hostnamectl hostname br-rtr.au-team.irpo <br>
        BR-SRV: hostnamectl hostname br-srv.au-team.irpo <br>
        CLI: hostnamectl set-hostname hq-cli.au-team.irpo <br>
        <hr>
        Раздаем айпи адреса: <br>
        HQ-RTR: ens33: <br>
        адрес: 172.16.4.1/28 <br>
        шлюз: 172.16.4.14 <br>
        сервер: 8.8.8.8 <br>
        ens34: адрес: 192.168.100.10/26 <br>
        ens35: адрес: 192.168.200.10/28 <br>
        <br>
        BR-RTR: ens33: <br>
        адрес: 172.16.5.1/28 <br>
        шлюз: 172.16.5.14 <br>
        сервер: 8.8.8.8 <br>
        ens34: адресс: 172.30.100.10/27 <br>
        <br>
        HQ-SRV: ens33: <br>
        адрес: 192.168.100.1/26 <br>
        шлю: 192.168.100.10 <br>
        сервер6 8.8.8.8 <br>
        <br>
        BR-SRV: ens33: <br>
        адресс: 172.30.100.1/27 <br>
        шлюз: 172.30.100.10 <br>
        сервер: 8.8.8.8 <br>
        <br>
        ISP: ens34: <br>
        адресс: 172.16.4.14/28 <br>
        ens35: <br>
        адрес: 172.16.5.14/28 <br>
        <hr>
        На ISP/BR-RTR/HQ-RTR пишем: <br>
        echo “net.ipv4.ip_forward=1” >> /etc/sysctl.conf <br>
        sysctl -p
        <hr>
        На ISP: <br>
        iptables -A FORWARD -s 172.16.0.0/16 -j ACCEPT <br>
        iptables -A FORWARD -d 172.16.0.0/16 -j ACCEPT <br>
        iptables -t nat -A POSTROUTING -o ens33 -s 172.16.4.0/16 -j MASQUERADE <br>
        systemctl stop firewalld <br>
        systemctl disable firewalld <br>
        iptables-save <br>
        iptables-save > /etc/sysconfig/iptables <br>
        <br>
        Проверяем на ртршках ping 8.8.8.8
        <hr>
        Создаем пользователей sshuser на HQ-SRV и BR-SRV: <br>
        useradd -m -U -s /bin/bash sshuser <br>
        passwd sshuser <br>
        P@ssw0rd <br>
        P@ssw0rd <br>
        echo "sshuser ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers <br>
        <hr>
        Создаем пользователей net-admin на HQ-RTR и BR-RTR: <br>
        useradd -m -U -s /bin/bash net_admin <br>
        passwd net_admin <br>
        P@$$w0rd <br>
        P@$$w0rd <br>
        echo "net_admin ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers <br>
        <hr>
        Отключаем SELINUX на HQ-SRV и BR-SRV: <br>
        nano /etc/selinux/config <br>
        Enforcing заменить на disabled (первая строчка без комментария) <br>
        Для применения изменений, перезапускаем сервера: <br>
        reboot <br>
        <br>
        Настраиваем SSH на HQ-SRV и BR-SRV: <br> 
        echo “Authorized access only” > /opt/banner <br>
        nano /etc/ssh/sshd_config <br>
        Port 2024 <br>
        AllowUsers sshuser <br>
        MaxAuthTries 2 <br>
        Banner /opt/banner <br>
        Сохраняем изменения. <br>
        Перезапускаем ssh: <br>
        systemctl restart sshd <br>
        <br>
        Проверяем пинг ssh на HQ-SRV: shh -l sshuser 172.30.100.1 -p 2024 <br>
        на BR-SRV: shh -l sshuser 192.168.100.1 -p 2024 <br>
        <hr>
        На RTRшках создаем туннель: <br>
        HQ-RTR: <br>
        Имя профиля: gre1 <br>
        Устройство: gre1 <br>
        Родительский: ens33 <br>
        Локальный: 172.16.4.1 <br>
        Удаленный: 172.16.5.1 <br>
        Адрес: 10.10.10.1/30 <br>
        <br>
        BR-RTR: <br>
        Имя профиля: gre1 <br>
        Устройство: gre1 <br>
        Родительский: ens33 <br>
        Локальный: 172.16.5.1 <br>
        Удаленный: 172.16.4.1 <br>
        Адрес: 10.10.10.2/30 <br>
        <br>
        После этого на обоих роутерах пишем: <br>
        nmcli conn modify gre1 ip-tunnel.ttl 64 <br>
        Перезапускаем интерфейс тунела в nmtui <br>
        Проверяем пинги с двух роутеров на 10.10.10.1 и 10.10.10.2 <br>
        <hr>
        На HQ-RTR и BR-RTR пишем: <br>
        dnf install frr <br>
        systemctl enable --now frr <br>
        nano /etc/frr/daemons <br>
        заменить no на yes в ospfd=yes <br>
        systemctl restart frr <br>
        vtysh <br>
        ДАЛЕЕ РАБОТА КАК В CISCO <br>
        conf t <br>
        router ospf <br>
        <br>
        На HQ-RTR: <br>
        network 192.168.100.0/26 area 0 <br>
        network 192.168.200.0/28 area 0 <br>
        network 10.10.10.0/30 area 0 <br>
        ospf router-id 172.16.4.1 <br>
        passive-interface ens34 <br>
        passive-interface ens35 <br>
        area 0 authentication <br>
        exit <br>
        int gre1 <br>
        ip ospf authentication <br>
        ip ospf authentication-key P@ssw0rd <br>
        do wr <br>
        exit <br>
        exit <br>
        exit <br>
        <br>
        На BR-RTR: <br>
        network 172.30.100.10/27 area 0 <br>
        network 10.10.10.0/30 area 0 <br>
        ospf router-id 172.16.5.1 <br>
        passive-interface ens34 <br>
        area 0 authentication <br>
        exit <br>
        int gre1 <br>
        ip ospf authentication <br>
        ip ospf authentication-key P@ssw0rd <br>
        do wr <br>
        exit <br>
        exit <br>
        exit <br>
        <hr>
        На HQ-RTR и BR-RTR пишем: <br>
        systemctl --now enable firewalld <br>
        firewall-cmd --set-default-zone=trusted <br>
        firewall-cmd --zone=trusted --add-masquerade --permanent <br>
        systemctl restart firewalld <br>
        <hr>
        Пишем на HQ-RTR: <br>
        dnf install dhcp-server <br>
        nano /etc/dhcp/dhcpd.conf <br>
        Пишем это в файле: <br>
        subnet 192.168.200.0 netmask 255.255.255.240 { <br>
             range 192.168.200.1 192.168.200.14; <br>
             option subnet-mask 255.255.255.240; <br>
             option routers 192.168.200.10; <br>
             option broadcast-address 192.168.200.15; <br>
             option domain-name-servers 192.168.100.1; <br>
             option domain-name “au-team.irpo”; <br>
        } <br>
        host HQ-RTR { <br>
        	hardware ethernet 00:0c:29:6c:fa:a2; <br>
        	fixed-address 192.168.200.10; <br>
        } <br>
        Сохраняем что писали на файлике и далее пишем: <br>
        systemctl enable --now dhcpd <br>
        dhcpd <br>
        cat /var/lib/dhcpd/dhcpd/leases <br> 
        <hr>
        На HQ-SRV: <br> 
        dnf install bind <br> 
        nano /etc/named.conf <br> 
        Меняем строчки: <br> 
        на первой строчке в скобках меняем на any <br> 
        на последней строчке в скобках меняем на any <br> 
        дописываем еще одну строчку: <br> 
        forwarders { 8.8.8.8 }; <br> 
        <br>
        И в конце добавляем: <br>
        shift+наверх - выделяет <br> 
        alt+6 - копировать <br> 
        ctrl+u - вставлять <br> 
        zone "au-team.irpo" IN { <br> 
        	type primary; <br> 
        	file "/opt/dns/au-team.irpo"; <br> 
        }; <br> 
        zone "4.16.172.in-addr.arpa" IN { <br> 
        	type master; <br> 
        	file "/opt/dns/4.16.172.in-addr.arpa"; <br> 
        }; <br> 
         zone "100.168.192.in-addr.arpa" IN { <br> 
        	type master; <br> 
        	file "/opt/dns/100.168.192.in-addr.arpa"; <br> 
        }; <br> 
         zone "200.168.192.in-addr.arpa" IN { <br> 
        	type master; <br> 
        	file "/opt/dns/200.168.192.in-addr.arpa"; <br> 
        }; <br> 
        <br>
        Далеем пишем: <br> 
        mkdir /opt/dns <br> 
        cd /opt/dns <br> 
        cp /var/named/named.empty au-team.irpo <br> 
        nano au-team.irpo <br> 
        На файле сверху два раза пишем: <br>
        au-team.irpo. <br>
        В конце файла дописываем: <br>
        hq-rtr	IN 	A 	172.16.4.1 <br>
        br-rtr	IN 	A 	172.16.5.1 <br>
        hq-srv	IN 	A 	192.168.100.1 <br>
        hq-cli	IN 	A 	192.168.200.1 <br>
        br-srv	IN 	A 	172.30.100.1 <br>
        wiki	CNAME 	172.16.4.1 <br>
        moodle	CNAME 	172.16.4.1 <br>
        Сохраняем изменения и далее пишем: <br>
        cp /var/named/named.empty 4.16.172.in-addr.arpa <br>
        nano 4.16.172.in-addr.arpa <br>
        В файле пишем: <br>
        На файле сверху один раз пишем: <br>
        au-team.irpo. <br>
        В конце файла дописываем: <br>
        10 IN 	PTR 	hq-rtr.au-team.irpo. <br>
        Сохраняем изменения и далее пишем: <br>
        cp /var/named/named.empty 100.168.192.in-addr.arpa <br>
        nano 100.168.192.in-addr.arpa <br>
        На файле сверху один раз пишем: <br>
        au-team.irpo. <br>
        В конце файла дописываем: <br>
        @ 	IN 	NS 	localhost. <br>
        1 	IN 	PTR 	hq-srv. <br>
        Сохраняем изменения и далее пишем: <br>
        cp /var/named/named.empty 200.168.192.in-addr.arpa <br>
        nano 200.168.192.in-addr.arpa <br>
        На файле сверху один раз пишем: <br>
        au-team.irpo. <br>
        В конце файла дописываем: <br>
        @ 	IN 	NS 	localhost. <br>
        2 	IN 	PTR 	hq-cli. <br>
        <br>
        После этого пишем: <br>
        chmod -R 777 /opt/dns <br>
        Проверяем конфигурацию и исправляем ошибки если есть: <br>
        named-checkconf -z <br>
        systemctl restart named <br>
        <hr>
        Заходим на hq-cli, нажимаем на кнопку подключения <br>
        (между сменой языка и уровнем громкости сверху справа) <br>
        Нажимаем на стрелочку около слово "Проводное" <br>
        Выбираем настройки подключения <br>
        Затем рядом с "Подключено - 1000 Мб/с" нажимаем на шестеренку <br>
        В появившемся окне переходим на вкладку IPv4 <br>
        Выключаем автоматический днс и указываем 192.168.100.1 <br>
        На hq-cli заходим в nmtui и указываем домен поиска au-team.irpo <br>
        НА HQ-CLI ПРОВЕРЯЕМ ПИНГИ: <br>
        ping br-rtr <br>
        ping br-srv <br>
        ping hq-rtr <br>
        ping hq-srv <br>
        ping ya.ru <br>
        <hr>
        Далее заходим на другие устройства (кроме ISP) и на ens33 сервера меняем с <br>
        8.8.8.8 на 192.168.100.1 <br>
        Тажке пишем домен поиска: au-team.irpo <br>
        И пингуем с друг машин другие <br>
        <hr>
        Настраиваем во всех машинах часовой пояс: <br>
        timedatectl set-timezone Europe/Moscow <br>
        timedatectl (проверка ОБЯЗАТЕЛЬНО!) <br>
        
















       
        
    </h10>
</body>
</html>